Function
[def extended_euclid(a: int, b: int) -> Tuple[int, int]:]
[def chinese_remainder_theorem(n1: int, r1: int, n2: int, r2: int) -> int:]
[def invert_modulo(a: int, n: int) -> int:]
[def chinese_remainder_theorem2(n1: int, r1: int, n2: int, r2: int) -> int:]
[def add(x,y):]
[def add(x,y):]
[def add(x,y)]
[def generate_key(message: str, key: str) -> str:]
[def cipher_text(message: str, key_new: str) -> str:]
[def original_text(cipher_text: str, key_new: str) -> str:]
[def __init__(self, group: int = 14) -> None:]
[def primitive_root(p_val: int) -> int:]
[def query(]
[def lowest_common_ancestor(]
[def breadth_first_search(]
[def sift_down(self, idx, array):]
[def __setitem__(self, index, data):]
[def push(self, new_data: Any):]
[def swap_nodes(self, node_data_1, node_data_2):]
[def printArray(arr, n):]
[def ucal(u: float, p: int) -> float:]
[def newton(]
[def test_convert_to_negative():]
[def test_change_contrast():]
[def test_gen_gaussian_kernel():]
[def test_canny():]
[def test_gen_gaussian_kernel_filter():]
[def _fib(n: int) -> tuple[int, int]:]
[def PrintOptimalSolution(OptimalSolution, i, j):]
[def evaluate(item: str, main_target: str = target) -> tuple[str, float]:]
[def select(parent_1: tuple[str, float]) -> list[str]:]
[def computeAP(l): # noqa: E741]
[def search(grid, init, goal, cost, heuristic):]
[def find_isolated_nodes(graph):]
[def checkBipartite(graph):]
[def check_bipartite_dfs(graph):]
[def print_graph(self) -> None:]
[def add_edge(self, from_vertex: int, to_vertex: int) -> None:]
[def __init__(self):]
[def depth_first_search(self, vertex, sink, flow):]
[def max_flow(self, source, sink):]
[def add_pair(self, u, v, w=1):]
[def remove_pair(self, u, v):]
[def dfs(self, s=-2, d=-1):]
[def fill_graph_randomly(self, c=-1):]
[def add_pair(self, u, v, w=1):]
[def remove_pair(self, u, v):]
[def dfs(self, s=-2, d=-1):]
[def fill_graph_randomly(self, c=-1):]
[def _normalizeGraph(self, sources, sinks):]
[def _algorithm(self):]
[def dfs(u, graph, visited_edge, path=[]):]
[def check_circuit_or_path(graph, max_node):]
[def computeBridges(graph):]
[def longestDistance(graph):]
[def __init__(self, key: int) -> None:]
[def __init__(self):]
[def bottom_to_top(val, index, heap, position):]
[def xorshift(X, Y):]
[def text_to_bits(text, encoding="utf-8", errors="surrogatepass"):]
[def emitterConverter(sizePar, data):]
[def expand_block(self, block):]
[def gaussian_distribution(mean: float, std_dev: float, instance_count: int) -> list:]
[def y_generator(class_count: int, instance_count: list) -> list:]
[def calculate_mean(instance_count: int, items: list) -> float:]
[def calculate_probabilities(instance_count: int, total_count: int) -> float:]
[def calculate_variance(items: list, means: list, total_count: int) -> float:]
[def predict_y_values(]
[def accuracy(actual_y: list, predicted_y: list) -> float:]
[def main():]
[def logistic_reg(alpha, X, y, max_iterations=70000):]
[def viz_polymonial():]
[def mae(predict, actual):]
[def mse(predict, actual):]
[def rmse(predict, actual):]
[def rmsle(predict, actual):]
[def mbd(predict, actual):]
[def fit(self):]
[def predict(self, test_samples, classify=True):]
[def _check_obey_kkt(self, index):]
[def _k(self, i1, i2):]
[def _e(self, index):]
[def _calculate_k_matrix(self):]
[def _predict(self, sample):]
[def _choose_alphas(self):]
[def _get_new_alpha(self, i1, i2, a1, a2, e1, e2, y1, y2):]
[def _norm(self, data):]
[def NuSVC(train_x, train_y):]
[def totient(n: int) -> list:]
[def find_max(nums, left, right):]
[def find_min(nums, left, right):]
[def lucas_lehmer_test(p: int) -> bool:]
[def is_prime(n, prec=1000):]
[def is_in_circle(x: float, y: float) -> bool:]
[def __DFT(self, which):]
[def __multiply(self):]
[def __str__(self):]
[def sum_of_series(first_term, common_diff, num_of_terms):]
[def __init__(self, row: int, col: int, graph: list):]
[def columns(self):]
[def add_row(self, row, position=None):]
[def __eq__(self, other):]
[def single_line(row_vector):]
[def floyd(n):]
[def reverse_floyd(n):]
[def pretty_print(n):]
[def alternative_password_generator(ctbi, i):]
[def update(frame: int) -> list[plt.Circle]:]
[def hand_name(self) -> str:]
[def __eq__(self, other):]
[def _modexpt(base: int, exponent: int, modulo_value: int) -> int:]
[def pre_order_iter(node: TreeNode) -> None:]
[def iter_merge_sort(input_list: list) -> list:]
[def main():]
[def __init__(self, val):]
[def fetch_last_half_hour() -> str:]
[def fetch_from_to(start, end) -> list:]
[def get_domain_name(url: str) -> str:]
[def get_sub_domain_name(url: str) -> str:]